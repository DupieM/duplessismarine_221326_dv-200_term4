{"version":3,"file":"index.module.js","sources":["../../src/constants.ts","../../src/utils.ts","../../src/index.tsx"],"sourcesContent":["import { JSX } from 'solid-js/jsx-runtime';\nimport { isServer } from 'solid-js/web';\n\nexport const KEYS = {\n  BACKSPACE: 'Backspace',\n  ENTER: 'Enter',\n  ESCAPE: 'Escape',\n  m: 'm',\n  M: 'M',\n  TAB: 'Tab',\n  y: 'y',\n  z: 'z',\n} as const;\n\nexport const ENCLOSING_PAIRS = {\n  '(': ['(', ')'],\n  '[': ['[', ']'],\n  '{': ['{', '}'],\n  '\\'': ['\\'', '\\''],\n  '\"': ['\"', '\"'],\n  '`': ['`', '`'],\n};\n\nconst userAgent = isServer ? '' : window?.navigator?.userAgent ?? '';\n\nexport const isWindows = /win/i.test(userAgent);\nexport const isMacLike = /(mac|iphone|ipad|ipod)/i.test(userAgent);\n\nexport const TEXTAREA_CLASS = 'npm__solid-simple-code-editor__textarea';\n\nexport const SHOW_PLACEHOLDER_STYLES = /* CSS */ `\n/**\n * Reset the text fill color to make placeholder visible when there\n * is no text\n */\n.${TEXTAREA_CLASS}:placeholder-shown {\n  -webkit-text-fill-color: inherit !important;\n}\n`;\n\nexport const STYLES: Readonly<Record<'CONTAINER' | 'TEXTAREA' | 'HIGHLIGHT' | 'EDITOR', JSX.CSSProperties>> = {\n  CONTAINER: {\n    'box-sizing': 'border-box',\n    'text-align': 'left',\n    overflow: 'hidden',\n    padding: 0,\n    position: 'relative',\n  },\n  TEXTAREA: {\n    '-moz-osx-font-smoothing': 'grayscale',\n    '-webkit-font-smoothing': 'antialiased',\n    '-webkit-text-fill-color': 'transparent',\n    color: 'inherit',\n    height: '100%',\n    left: 0,\n    overflow: 'hidden',\n    position: 'absolute',\n    resize: 'none',\n    top: 0,\n    width: '100%',\n  },\n  HIGHLIGHT: {\n    'pointer-events': 'none',\n    position: 'relative',\n  },\n  EDITOR: {\n    'box-sizing': 'inherit',\n    'font-family': 'inherit',\n    'font-size': 'inherit',\n    'font-style': 'inherit',\n    'font-variant-ligatures': 'inherit',\n    'font-weight': 'inherit',\n    'letter-spacing': 'inherit',\n    'line-height': 'inherit',\n    'overflow-wrap': 'break-word',\n    'tab-size': 'inherit',\n    'text-indent': 'inherit',\n    'text-rendering': 'inherit',\n    'text-transform': 'inherit',\n    'white-space': 'pre-wrap',\n    'word-break': 'keep-all',\n    background: 'none',\n    border: 0,\n    display: 'inherit',\n    margin: 0,\n  },\n};\n","import { mergeProps } from 'solid-js';\nimport { ENCLOSING_PAIRS, KEYS, isMacLike, isWindows } from './constants';\n\ntype DefaultAdded<Source extends object, Defaults extends Partial<Source>> = {\n  [key in keyof (Source & Defaults)]: key extends keyof Source ? NonNullable<Source[key]> : never;\n};\n\n/**\n * Merges two objects maintaining reactivity.\n *\n * @param source The source object\n * @param defaults The default values\n * @returns The merged object\n */\nexport const mergeDefaults = <T extends object, D extends Partial<T>>(\n  source: T,\n  defaults: D,\n) => mergeProps(defaults, source) as DefaultAdded<T, D>;\n\n/**\n * Given a set of string arguments, join the values together into a string with\n * spaces. Falsey values will be omitted,\n * e.g. classNames(['A', 'B', false, 'D', false]) --> 'A B D'\n * @param inputs The set of values\n * @returns The values joined as a string, or blank string if no values\n */\nexport const clsx = (...inputs: (string | boolean | undefined)[]) =>\n  inputs.filter(Boolean).join(' ');\n  \n/**\n * Gets the specified lines from a multi-line text.\n * @param text The text from which the styles need to be extracted\n * @param position The end position\n * @returns The specified lines.\n */\nexport const getLines = (text: string, position: number) =>\n  text.substring(0, position).split('\\n');\n  \n/**\n * Checks if a character is one of the enclosing characters.\n * @param char The character to be tested\n * @returns whether the character is an enclosing character\n */\nexport const isEnclosingCharacter = (char: string): char is keyof typeof ENCLOSING_PAIRS => (char in ENCLOSING_PAIRS);\n\n/**\n * Checks if a keyboard action is an undo action\n * @param event The keyboard event\n * @returns whether the key stroke corresponds to an undo action\n */\nexport const isUndo = (event: KeyboardEvent) => (\n  (isMacLike\n    // Undo in Mac will be command + z\n    ? event.metaKey && event.key === KEYS.z\n    // In all other platforms, it will be Ctrl + z\n    : event.ctrlKey && event.key === KEYS.z\n  ) &&\n  !event.shiftKey &&\n  !event.altKey\n);\n\n/**\n * Checks if a keyboard action is a redo action\n * @param event The keyboard event\n * @returns whether the key stroke corresponds to a redo action\n */\nexport const isRedo = (event: KeyboardEvent) => (\n  (isMacLike\n    // Redo in Mac will be command + shift + Z\n    ? event.metaKey && event.shiftKey && event.key === KEYS.z\n    : isWindows\n      // In windows, it will be Ctrl + y\n      ?  event.ctrlKey && event.key === KEYS.y && !event.shiftKey\n      // In all other platforms, it will Ctrl + shift + y\n      : event.ctrlKey && event.shiftKey && event.key === KEYS.z\n  ) &&\n  !event.altKey\n);\n\n/**\n * Checks if a keyboard action is a capture toggle action\n * @param event The keyboard event\n * @returns whether the key stroke corresponds to a capture toggle action\n */\nexport const isCaptureToggle = (event: KeyboardEvent) => (\n  // Capture toggle action in Mac will be Ctrl + Shift + M\n  // And in all other machines, it will be Ctrl + M\n  (event.key === KEYS.m || event.key === KEYS.M) &&\n  event.ctrlKey &&\n  (isMacLike ? event.shiftKey : true)\n);\n\n/***************************\n * UNDO/REDO History setup *\n ***************************/\nconst HISTORY_LIMIT = 100;\nconst HISTORY_TIME_GAP = 3000;\n\nexport type Record = {\n  value: string;\n  selectionStart: number;\n  selectionEnd: number;\n};\n\nexport type History = {\n  stack: (Record & { timestamp: number })[];\n  offset: number;\n};\n\n/**\n * Records a change in the history.\n * @param history The instance of the history being used\n * @param record The change record\n * @param overwrite Whether the record should overwrite the history\n */\nexport const recordChange = (history: History, record: Record, overwrite = false) => {  \n  // Cleanup the current stack if it is not empty\n  if (history.stack.length && history.offset > -1) {\n    const { stack, offset } = history;\n    // when something updates, drop the redo ops\n    history.stack = stack.slice(0, offset + 1);\n    \n    // Limit the history to the HISTORY_LIMIT\n    const count = history.stack.length;\n    if (count > HISTORY_LIMIT) {\n      const extras = count - HISTORY_LIMIT;\n      history.stack = stack.slice(extras, count);\n      history.offset = Math.max(history.offset - extras, 0);\n    }\n  }\n  \n  // current timestamp for the record\n  const timestamp = Date.now();\n  \n  // if set to overwrite, overwrite the last entry\n  if (overwrite) {\n    const last = history.stack[history.offset];\n    \n    // check if a previous entry exists and was in short interval\n    if (last && timestamp - last.timestamp < HISTORY_TIME_GAP) {\n      // Match teh last word in the line\n      const lastWordRegex = /[^a-z0-9]([a-z0-9]+)$/i;\n      \n      // Get the previous line\n      const previous = getLines(last.value, last.selectionStart)\n        .pop()\n        ?.match(lastWordRegex);\n      \n      // Get the current line\n      const current = getLines(record.value, record.selectionStart)\n        .pop()\n        ?.match(lastWordRegex);\n        \n      // If the last and the previous words match, then overwrite the\n      // previous entry so that undo will remove the whole word\n      if (previous?.[1] && current?.[1]?.startsWith(previous[1])) {\n        history.stack[history.offset] = { ...record, timestamp };\n        return;\n      }\n    }\n  }\n  \n  // Add the new record to the stack\n  history.stack.push({ ...record, timestamp });\n  history.offset += 1;\n};\n","import { Component, JSX, JSXElement, createMemo, onMount, splitProps } from 'solid-js';\nimport { ENCLOSING_PAIRS, KEYS, SHOW_PLACEHOLDER_STYLES, STYLES, TEXTAREA_CLASS } from './constants';\nimport { type History, type Record, clsx, mergeDefaults, recordChange, getLines, isEnclosingCharacter, isUndo, isRedo, isCaptureToggle } from './utils';\n\ntype Padding = JSX.CSSProperties['padding'] |\n  Pick<JSX.CSSProperties,\n    | 'padding-block'\n    | 'padding-block-end'\n    | 'padding-block-start'\n    | 'padding-bottom'\n    | 'padding-inline'\n    | 'padding-inline-end'\n    | 'padding-inline-start'\n    | 'padding-left'\n    | 'padding-right'\n    | 'padding-top'\n  >;\n\ntype PropsFromTextArea = \n  | 'autofocus'\n  | 'disabled'\n  | 'form'\n  | 'maxLength'\n  | 'minLength'\n  | 'name'\n  | 'onBlur'\n  | 'onClick'\n  | 'onFocus'\n  | 'onKeyDown'\n  | 'onKeyUp'\n  | 'placeholder'\n  | 'readOnly'\n  | 'required';\ntype PickedTextAreaProperties = Pick<\n  JSX.TextareaHTMLAttributes<HTMLTextAreaElement>,\n  PropsFromTextArea\n>;\ntype PickedDivProperties = Omit<JSX.HTMLAttributes<HTMLDivElement>, 'style' | PropsFromTextArea>;\n\ntype Props = PickedDivProperties & PickedTextAreaProperties & {\n  /**************************\n   * Props of the component *\n   **************************/\n\n  /**\n   * Callback which will receive text to highlight. You'll need to\n   * return an HTML string or a React element with syntax highlighting\n   * using a library such as prismjs.\n   * @param value The value of the component\n   * @returns The highlighted elements\n   */\n  highlight: (value: string) => JSXElement;\n\n  /**\n   * Whether the editor should ignore tab key presses so that keyboard\n   * users can tab past the editor. Users can toggle this behavior using\n   * Ctrl+Shift+M (Mac) / Ctrl+M manually when this is false.\n   * @default false\n   */\n  ignoreTabKey?: boolean;\n\n  /**\n   * Whether to use spaces for indentation.\n   * If you set it to false, you might also want to set tabSize to 1.\n   * @default true\n   */\n  insertSpaces?: boolean;\n\n  /**\n   * Optional padding for code.\n   * @default 0\n   */\n  padding?: Padding;\n\n  /**\n   * Custom styles for the component.\n   */\n  style?: JSX.CSSProperties;\n\n  /**\n   * The number of characters to insert when pressing tab key.\n   * For example, for 4 space indentation, tabSize will be 4\n   * and insertSpaces will be true.\n   * @default 2\n   */\n  tabSize?: number;\n\n  /**\n   * Current value of the editor i.e. the code to display. This\n   * must be a controlled prop.\n   */\n  value: string;\n\n  /**\n   * Callback which is called when the value of the editor changes.\n   * You'll need to update the value prop when this is called.\n   * @param value The updated value\n   */\n  onValueChange: (value: string) => void;\n\n  /*****************************\n   * Props related to textarea *\n   *****************************/\n\n  /**\n   * The id for the underlying textarea element. This can be used for linking\n   * the text area to a label or other accessibility related mapping.\n   */\n  textareaId?: string;\n\n  /**\n   * A class name for the underlying textarea element. Can be useful for more precise\n   * control of its styles.\n   */\n  textareaClass?: string;\n\n  /************************\n   * Props related to pre *\n   ************************/\n\n  /**\n   * A class name for the underlying pre element. Can be useful for more precise\n   * control of its styles.\n   */\n  preClass?: string;\n};\n\nexport const Editor: Component<Props> = (props) => {\n  const fixedProps = mergeDefaults(props, {\n    ignoreTabKey: false,\n    insertSpaces: true,\n    padding: 0,\n    tabSize: 2,\n  });\n  const [local, rest] = splitProps(fixedProps, [\n    // Component props\n    'highlight',\n    'ignoreTabKey',\n    'insertSpaces',\n    'padding',\n    'style',\n    'tabSize',\n    'value',\n    'onValueChange',\n\n    // Custom textarea props\n    'textareaId',\n    'textareaClass',\n\n    // Custom pre props\n    'preClass',\n\n    // Textarea native props\n    'autofocus',\n    'disabled',\n    'form',\n    'maxLength',\n    'minLength',\n    'name',\n    'onBlur',\n    'onClick',\n    'onFocus',\n    'onKeyDown',\n    'onKeyUp',\n    'placeholder',\n    'readOnly',\n    'required',\n  ]);\n\n  /**********************\n   * Instance variables *\n   **********************/\n  let textareaElement: HTMLTextAreaElement | undefined;\n  const history: History = {\n    stack: [],\n    offset: -1\n  };\n  let shouldCaptureTab = true;\n\n  /***********************\n   * Computed properties *\n   ***********************/\n  const contentStyle = createMemo<JSX.CSSProperties>(() => (\n    typeof local.padding === 'object' ?\n      local.padding :\n      { padding: local.padding }\n  ));\n  const highlighted = createMemo(() => local.highlight(local.value));\n\n  /******************\n   * Helper methods *\n   ******************/\n  const updateInput = (record: Record) => {\n    if (!textareaElement) return;\n    \n    // update value and selection state\n    textareaElement.value = record.value;\n    textareaElement.selectionStart = record.selectionStart;\n    textareaElement.selectionEnd = record.selectionEnd;\n    \n    local.onValueChange(record.value);\n  };\n  \n  const applyEdits = (record: Record) => {\n    const last = history.stack[history.offset];\n    if (last && textareaElement) {\n      history.stack[history.offset] = {\n        ...last,\n        selectionEnd: textareaElement.selectionEnd,\n        selectionStart: textareaElement.selectionStart,\n      };\n    }\n    \n    // save the changes\n    recordChange(history, record);\n    updateInput(record);\n  };\n  \n  const undoEdit = () => {\n    const prevRecord = history.stack[history.offset - 1];\n    if (prevRecord) {\n      updateInput(prevRecord);\n      history.offset = Math.max(history.offset - 1, 0);\n    }\n  };\n  \n  const redoEdit = () => {\n    const nextRecord = history.stack[history.offset + 1];\n    if (nextRecord) {\n      updateInput(nextRecord);\n      history.offset = Math.min(history.offset + 1, history.stack.length - 1);\n    }\n  };\n\n  /******************\n   * Event handlers *\n   ******************/\n  const handleChange: JSX.ChangeEventHandler<HTMLTextAreaElement, Event> = (event) => {\n    const { selectionEnd, selectionStart, value } = event.target;\n    recordChange(\n      history,\n      {\n        selectionEnd,\n        selectionStart,\n        value,\n      },\n      true,\n    );\n    local.onValueChange(value);\n  };\n\n  const handleKeyDown: JSX.EventHandler<HTMLTextAreaElement, KeyboardEvent> = (event) => {\n    // call the handler if provider\n    if (typeof local.onKeyDown === 'function') {\n      local.onKeyDown(event);\n      \n      // if default prevented, return\n      if (event.defaultPrevented) {\n        return;\n      }\n    }\n    \n    // Blur on escape\n    if (event.key === KEYS.ESCAPE) {\n      event.currentTarget.blur();\n    }\n    \n    const { selectionEnd, selectionStart, value } = event.currentTarget;\n    const tabCharacter = (local.insertSpaces ? ' ' : '\\t').repeat(local.tabSize!);\n    const hasSelection = selectionStart !== selectionEnd;\n    \n    if (event.key === KEYS.TAB && !local.ignoreTabKey && shouldCaptureTab) {\n      // prevent focus change\n      event.preventDefault();\n      \n      if (event.shiftKey) {\n        // Unindent selected lines on shift + tab\n        const linesBeforeCaret = getLines(value, selectionStart);\n        const linesAfterCaret = getLines(value, selectionEnd);\n        const startLine = linesBeforeCaret.length - 1;\n        const endLine = linesAfterCaret.length - 1;\n        const nextValue = value\n          .split('\\n')\n          .map((line, index) => {\n            // if able to shift left indentation, do that else\n            // return the original line\n            if (\n              index >= startLine &&\n              index <= endLine &&\n              line.startsWith(tabCharacter)\n            ) return line.substring(tabCharacter.length);\n            return line;\n          })\n          .join('\\n');\n        \n        // If the value has changed, apply the edits\n        if (value !== nextValue) {\n          const startLineText = linesBeforeCaret[startLine];\n          applyEdits({\n            value: nextValue,\n            // Move the start cursor if first line in selection was modified\n            // It was modified only if it started with a tab\n            selectionStart: startLineText?.startsWith(tabCharacter)\n              ? selectionStart - tabCharacter.length\n              : selectionStart,\n            // Move the cursor by total number of characters removed\n            selectionEnd: selectionEnd - (value.length - nextValue.length),\n          });\n        }\n      } else if (hasSelection) {\n        // Indent on tab and only if there is a selection\n        const linesBeforeCaret = getLines(value, selectionStart);\n        const linesAfterCaret = getLines(value, selectionEnd);\n        const startLine = linesBeforeCaret.length - 1;\n        const endLine = linesAfterCaret.length - 1;\n        const startLineText = linesBeforeCaret[startLine];\n\n        applyEdits({\n          value: value\n            .split('\\n')\n            .map((line, index) => {\n              if (index >= startLine && index <= endLine) return tabCharacter + line;\n              return line;\n            })\n            .join('\\n'),\n          // Move the start cursor by number of characters added in first line of selection\n          // Don't move it if it there was no text before cursor\n          selectionStart:\n            startLineText && /\\S/.test(startLineText)\n              ? selectionStart + tabCharacter.length\n              : selectionStart,\n          // Move the end cursor by total number of characters added\n          selectionEnd:\n            selectionEnd + tabCharacter.length * (endLine - startLine + 1),\n        });\n      } else {\n        // If there is no selection, simply insert a tab at the caret position\n        const updatedSelection = selectionStart + tabCharacter.length;\n        applyEdits({\n          // Insert tab character at caret\n          value:\n            value.substring(0, selectionStart) +\n            tabCharacter +\n            value.substring(selectionEnd),\n          // Update caret position\n          selectionStart: updatedSelection,\n          selectionEnd: updatedSelection,\n        });\n      }\n    } else if (event.key === KEYS.BACKSPACE) {\n      // On Backspace remove all the tab characters before the caret\n      const textBeforeCarat = value.substring(0, selectionStart);\n      \n      if (textBeforeCarat.endsWith(tabCharacter) && !hasSelection) {\n        // prevent default behavior\n        event.preventDefault();\n        const updatedSelection = selectionStart - tabCharacter.length;\n        \n        applyEdits({\n          // Remove tab character at caret\n          value:\n            value.substring(0, updatedSelection) +\n            value.substring(selectionEnd),\n          // Update caret position\n          selectionStart: updatedSelection,\n          selectionEnd: updatedSelection,\n        });\n      }\n    } else if (event.key === KEYS.ENTER) {\n      // On enter add indentation correctly and only when there\n      // is no selection.\n      if (!hasSelection) {\n        // Get the current line\n        const line = getLines(value, selectionStart).pop();\n        // Check if the current line has any indentation\n        const matches = line?.match(/^\\s+/);\n\n        if (matches?.[0]) {\n          // prevent the default action\n          event.preventDefault();\n\n          // Preserve indentation on inserting a new line\n          const indent = '\\n' + matches[0];\n          const updatedSelection = selectionStart + indent.length;\n\n          applyEdits({\n            // Insert indentation character at caret\n            value:\n              value.substring(0, selectionStart) +\n              indent +\n              value.substring(selectionEnd),\n            // Update caret position\n            selectionStart: updatedSelection,\n            selectionEnd: updatedSelection,\n          });\n        }\n      }\n    } else if (isEnclosingCharacter(event.key)) {\n      // if there is a selection, then enclose them in the characters\n      if (hasSelection) {\n        // prevent default\n        event.preventDefault();\n        \n        const chars = ENCLOSING_PAIRS[event.key];\n        applyEdits({\n          value:\n            value.substring(0, selectionStart) +\n            chars[0] +\n            value.substring(selectionStart, selectionEnd) +\n            chars[1] +\n            value.substring(selectionEnd),\n          // Update caret position\n          selectionStart,\n          selectionEnd: selectionEnd + 2,\n        });\n      }\n    } else if (isUndo(event)) {\n      event.preventDefault();\n      undoEdit();\n    } else if (isRedo(event)) {\n      event.preventDefault();\n      redoEdit();\n    } else if (isCaptureToggle(event)) {\n      event.preventDefault();\n      shouldCaptureTab = !shouldCaptureTab;\n    }\n  };\n\n  /*******************\n   * Lifecycle hooks *\n   *******************/\n\n  onMount(() => {\n    if (!textareaElement) return;\n    recordChange(\n      history,\n      {\n        selectionEnd: textareaElement.selectionEnd,\n        selectionStart: textareaElement.selectionStart,\n        value: textareaElement.value\n      }\n    );\n  });\n\n  return (\n    <div {...rest} style={{ ...STYLES.CONTAINER, ...local.style }}>\n      <textarea\n        ref={textareaElement}\n        autocapitalize=\"off\"\n        autocomplete=\"off\"\n        autofocus={local.autofocus}\n        class={clsx(TEXTAREA_CLASS, local.textareaClass)}\n        data-gramm={false}\n        disabled={local.disabled}\n        form={local.form}\n        id={local.textareaId}\n        maxLength={local.maxLength}\n        minLength={local.minLength}\n        name={local.name}\n        onBlur={local.onBlur}\n        onInput={handleChange}\n        onClick={local.onClick}\n        onFocus={local.onFocus}\n        onKeyDown={handleKeyDown}\n        onKeyUp={local.onKeyUp}\n        placeholder={local.placeholder}\n        readOnly={local.readOnly}\n        required={local.required}\n        spellcheck={false}\n        style={{ ...STYLES.EDITOR, ...STYLES.TEXTAREA, ...contentStyle() }}\n        value={local.value}\n      />\n      <pre\n        aria-hidden=\"true\"\n        class={local.preClass}\n        style={{\n          ...STYLES.EDITOR,\n          ...STYLES.HIGHLIGHT,\n          ...contentStyle()\n        }}\n        {...(\n          typeof highlighted() === 'string' ?\n            { innerHTML: `${highlighted()}<br/>` } :\n            { children: highlighted() }\n        )}\n      />\n      <style innerHTML={SHOW_PLACEHOLDER_STYLES} />\n    </div>\n  );\n};\n\nexport default Editor;\n"],"names":["TEXTAREA_CLASS","SHOW_PLACEHOLDER_STYLES","STYLES","CONTAINER","overflow","padding","position","TEXTAREA","color","height","left","resize","top","width","HIGHLIGHT","EDITOR","background","border","display","margin","mergeDefaults","source","defaults","mergeProps","clsx","inputs","filter","Boolean","join","Editor","props","fixedProps","ignoreTabKey","insertSpaces","tabSize","local","rest","splitProps","contentStyle","createMemo","highlighted","highlight","value","onMount","_$ssrElement","_$mergeProps","style","_$ssr","_tmpl$","_$ssrAttribute","autofocus","_$escape","textareaClass","disabled","form","textareaId","maxLength","minLength","name","placeholder","readOnly","required","_$ssrStyle","class","preClass","innerHTML","children","undefined","_tmpl$2"],"mappings":"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"}