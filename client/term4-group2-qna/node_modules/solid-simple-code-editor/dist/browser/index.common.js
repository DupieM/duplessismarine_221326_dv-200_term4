'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var web = require('solid-js/web');
var solidJs = require('solid-js');

const KEYS = {
  BACKSPACE: 'Backspace',
  ENTER: 'Enter',
  ESCAPE: 'Escape',
  m: 'm',
  M: 'M',
  TAB: 'Tab',
  y: 'y',
  z: 'z'
};
const ENCLOSING_PAIRS = {
  '(': ['(', ')'],
  '[': ['[', ']'],
  '{': ['{', '}'],
  '\'': ['\'', '\''],
  '"': ['"', '"'],
  '`': ['`', '`']
};
const userAgent = web.isServer ? '' : window?.navigator?.userAgent ?? '';
const isWindows = /win/i.test(userAgent);
const isMacLike = /(mac|iphone|ipad|ipod)/i.test(userAgent);
const TEXTAREA_CLASS = 'npm__solid-simple-code-editor__textarea';
const SHOW_PLACEHOLDER_STYLES = /* CSS */`
/**
 * Reset the text fill color to make placeholder visible when there
 * is no text
 */
.${TEXTAREA_CLASS}:placeholder-shown {
  -webkit-text-fill-color: inherit !important;
}
`;
const STYLES = {
  CONTAINER: {
    'box-sizing': 'border-box',
    'text-align': 'left',
    overflow: 'hidden',
    padding: 0,
    position: 'relative'
  },
  TEXTAREA: {
    '-moz-osx-font-smoothing': 'grayscale',
    '-webkit-font-smoothing': 'antialiased',
    '-webkit-text-fill-color': 'transparent',
    color: 'inherit',
    height: '100%',
    left: 0,
    overflow: 'hidden',
    position: 'absolute',
    resize: 'none',
    top: 0,
    width: '100%'
  },
  HIGHLIGHT: {
    'pointer-events': 'none',
    position: 'relative'
  },
  EDITOR: {
    'box-sizing': 'inherit',
    'font-family': 'inherit',
    'font-size': 'inherit',
    'font-style': 'inherit',
    'font-variant-ligatures': 'inherit',
    'font-weight': 'inherit',
    'letter-spacing': 'inherit',
    'line-height': 'inherit',
    'overflow-wrap': 'break-word',
    'tab-size': 'inherit',
    'text-indent': 'inherit',
    'text-rendering': 'inherit',
    'text-transform': 'inherit',
    'white-space': 'pre-wrap',
    'word-break': 'keep-all',
    background: 'none',
    border: 0,
    display: 'inherit',
    margin: 0
  }
};

/**
 * Merges two objects maintaining reactivity.
 *
 * @param source The source object
 * @param defaults The default values
 * @returns The merged object
 */
const mergeDefaults = (source, defaults) => solidJs.mergeProps(defaults, source);

/**
 * Given a set of string arguments, join the values together into a string with
 * spaces. Falsey values will be omitted,
 * e.g. classNames(['A', 'B', false, 'D', false]) --> 'A B D'
 * @param inputs The set of values
 * @returns The values joined as a string, or blank string if no values
 */
const clsx = (...inputs) => inputs.filter(Boolean).join(' ');

/**
 * Gets the specified lines from a multi-line text.
 * @param text The text from which the styles need to be extracted
 * @param position The end position
 * @returns The specified lines.
 */
const getLines = (text, position) => text.substring(0, position).split('\n');

/**
 * Checks if a character is one of the enclosing characters.
 * @param char The character to be tested
 * @returns whether the character is an enclosing character
 */
const isEnclosingCharacter = char => char in ENCLOSING_PAIRS;

/**
 * Checks if a keyboard action is an undo action
 * @param event The keyboard event
 * @returns whether the key stroke corresponds to an undo action
 */
const isUndo = event => (isMacLike
// Undo in Mac will be command + z
? event.metaKey && event.key === KEYS.z
// In all other platforms, it will be Ctrl + z
: event.ctrlKey && event.key === KEYS.z) && !event.shiftKey && !event.altKey;

/**
 * Checks if a keyboard action is a redo action
 * @param event The keyboard event
 * @returns whether the key stroke corresponds to a redo action
 */
const isRedo = event => (isMacLike
// Redo in Mac will be command + shift + Z
? event.metaKey && event.shiftKey && event.key === KEYS.z : isWindows
// In windows, it will be Ctrl + y
? event.ctrlKey && event.key === KEYS.y && !event.shiftKey
// In all other platforms, it will Ctrl + shift + y
: event.ctrlKey && event.shiftKey && event.key === KEYS.z) && !event.altKey;

/**
 * Checks if a keyboard action is a capture toggle action
 * @param event The keyboard event
 * @returns whether the key stroke corresponds to a capture toggle action
 */
const isCaptureToggle = event =>
// Capture toggle action in Mac will be Ctrl + Shift + M
// And in all other machines, it will be Ctrl + M
(event.key === KEYS.m || event.key === KEYS.M) && event.ctrlKey && (isMacLike ? event.shiftKey : true);

/***************************
 * UNDO/REDO History setup *
 ***************************/
const HISTORY_LIMIT = 100;
const HISTORY_TIME_GAP = 3000;
/**
 * Records a change in the history.
 * @param history The instance of the history being used
 * @param record The change record
 * @param overwrite Whether the record should overwrite the history
 */
const recordChange = (history, record, overwrite = false) => {
  // Cleanup the current stack if it is not empty
  if (history.stack.length && history.offset > -1) {
    const {
      stack,
      offset
    } = history;
    // when something updates, drop the redo ops
    history.stack = stack.slice(0, offset + 1);

    // Limit the history to the HISTORY_LIMIT
    const count = history.stack.length;
    if (count > HISTORY_LIMIT) {
      const extras = count - HISTORY_LIMIT;
      history.stack = stack.slice(extras, count);
      history.offset = Math.max(history.offset - extras, 0);
    }
  }

  // current timestamp for the record
  const timestamp = Date.now();

  // if set to overwrite, overwrite the last entry
  if (overwrite) {
    const last = history.stack[history.offset];

    // check if a previous entry exists and was in short interval
    if (last && timestamp - last.timestamp < HISTORY_TIME_GAP) {
      // Match teh last word in the line
      const lastWordRegex = /[^a-z0-9]([a-z0-9]+)$/i;

      // Get the previous line
      const previous = getLines(last.value, last.selectionStart).pop()?.match(lastWordRegex);

      // Get the current line
      const current = getLines(record.value, record.selectionStart).pop()?.match(lastWordRegex);

      // If the last and the previous words match, then overwrite the
      // previous entry so that undo will remove the whole word
      if (previous?.[1] && current?.[1]?.startsWith(previous[1])) {
        history.stack[history.offset] = {
          ...record,
          timestamp
        };
        return;
      }
    }
  }

  // Add the new record to the stack
  history.stack.push({
    ...record,
    timestamp
  });
  history.offset += 1;
};

const _tmpl$ = /*#__PURE__*/web.template(`<div><textarea autocapitalize="off" autocomplete="off"></textarea><pre aria-hidden="true"></pre><style>`);
const Editor = props => {
  const fixedProps = mergeDefaults(props, {
    ignoreTabKey: false,
    insertSpaces: true,
    padding: 0,
    tabSize: 2
  });
  const [local, rest] = solidJs.splitProps(fixedProps, [
  // Component props
  'highlight', 'ignoreTabKey', 'insertSpaces', 'padding', 'style', 'tabSize', 'value', 'onValueChange',
  // Custom textarea props
  'textareaId', 'textareaClass',
  // Custom pre props
  'preClass',
  // Textarea native props
  'autofocus', 'disabled', 'form', 'maxLength', 'minLength', 'name', 'onBlur', 'onClick', 'onFocus', 'onKeyDown', 'onKeyUp', 'placeholder', 'readOnly', 'required']);

  /**********************
   * Instance variables *
   **********************/
  let textareaElement;
  const history = {
    stack: [],
    offset: -1
  };
  let shouldCaptureTab = true;

  /***********************
   * Computed properties *
   ***********************/
  const contentStyle = solidJs.createMemo(() => typeof local.padding === 'object' ? local.padding : {
    padding: local.padding
  });
  const highlighted = solidJs.createMemo(() => local.highlight(local.value));

  /******************
   * Helper methods *
   ******************/
  const updateInput = record => {
    if (!textareaElement) return;

    // update value and selection state
    textareaElement.value = record.value;
    textareaElement.selectionStart = record.selectionStart;
    textareaElement.selectionEnd = record.selectionEnd;
    local.onValueChange(record.value);
  };
  const applyEdits = record => {
    const last = history.stack[history.offset];
    if (last && textareaElement) {
      history.stack[history.offset] = {
        ...last,
        selectionEnd: textareaElement.selectionEnd,
        selectionStart: textareaElement.selectionStart
      };
    }

    // save the changes
    recordChange(history, record);
    updateInput(record);
  };
  const undoEdit = () => {
    const prevRecord = history.stack[history.offset - 1];
    if (prevRecord) {
      updateInput(prevRecord);
      history.offset = Math.max(history.offset - 1, 0);
    }
  };
  const redoEdit = () => {
    const nextRecord = history.stack[history.offset + 1];
    if (nextRecord) {
      updateInput(nextRecord);
      history.offset = Math.min(history.offset + 1, history.stack.length - 1);
    }
  };

  /******************
   * Event handlers *
   ******************/
  const handleChange = event => {
    const {
      selectionEnd,
      selectionStart,
      value
    } = event.target;
    recordChange(history, {
      selectionEnd,
      selectionStart,
      value
    }, true);
    local.onValueChange(value);
  };
  const handleKeyDown = event => {
    // call the handler if provider
    if (typeof local.onKeyDown === 'function') {
      local.onKeyDown(event);

      // if default prevented, return
      if (event.defaultPrevented) {
        return;
      }
    }

    // Blur on escape
    if (event.key === KEYS.ESCAPE) {
      event.currentTarget.blur();
    }
    const {
      selectionEnd,
      selectionStart,
      value
    } = event.currentTarget;
    const tabCharacter = (local.insertSpaces ? ' ' : '\t').repeat(local.tabSize);
    const hasSelection = selectionStart !== selectionEnd;
    if (event.key === KEYS.TAB && !local.ignoreTabKey && shouldCaptureTab) {
      // prevent focus change
      event.preventDefault();
      if (event.shiftKey) {
        // Unindent selected lines on shift + tab
        const linesBeforeCaret = getLines(value, selectionStart);
        const linesAfterCaret = getLines(value, selectionEnd);
        const startLine = linesBeforeCaret.length - 1;
        const endLine = linesAfterCaret.length - 1;
        const nextValue = value.split('\n').map((line, index) => {
          // if able to shift left indentation, do that else
          // return the original line
          if (index >= startLine && index <= endLine && line.startsWith(tabCharacter)) return line.substring(tabCharacter.length);
          return line;
        }).join('\n');

        // If the value has changed, apply the edits
        if (value !== nextValue) {
          const startLineText = linesBeforeCaret[startLine];
          applyEdits({
            value: nextValue,
            // Move the start cursor if first line in selection was modified
            // It was modified only if it started with a tab
            selectionStart: startLineText?.startsWith(tabCharacter) ? selectionStart - tabCharacter.length : selectionStart,
            // Move the cursor by total number of characters removed
            selectionEnd: selectionEnd - (value.length - nextValue.length)
          });
        }
      } else if (hasSelection) {
        // Indent on tab and only if there is a selection
        const linesBeforeCaret = getLines(value, selectionStart);
        const linesAfterCaret = getLines(value, selectionEnd);
        const startLine = linesBeforeCaret.length - 1;
        const endLine = linesAfterCaret.length - 1;
        const startLineText = linesBeforeCaret[startLine];
        applyEdits({
          value: value.split('\n').map((line, index) => {
            if (index >= startLine && index <= endLine) return tabCharacter + line;
            return line;
          }).join('\n'),
          // Move the start cursor by number of characters added in first line of selection
          // Don't move it if it there was no text before cursor
          selectionStart: startLineText && /\S/.test(startLineText) ? selectionStart + tabCharacter.length : selectionStart,
          // Move the end cursor by total number of characters added
          selectionEnd: selectionEnd + tabCharacter.length * (endLine - startLine + 1)
        });
      } else {
        // If there is no selection, simply insert a tab at the caret position
        const updatedSelection = selectionStart + tabCharacter.length;
        applyEdits({
          // Insert tab character at caret
          value: value.substring(0, selectionStart) + tabCharacter + value.substring(selectionEnd),
          // Update caret position
          selectionStart: updatedSelection,
          selectionEnd: updatedSelection
        });
      }
    } else if (event.key === KEYS.BACKSPACE) {
      // On Backspace remove all the tab characters before the caret
      const textBeforeCarat = value.substring(0, selectionStart);
      if (textBeforeCarat.endsWith(tabCharacter) && !hasSelection) {
        // prevent default behavior
        event.preventDefault();
        const updatedSelection = selectionStart - tabCharacter.length;
        applyEdits({
          // Remove tab character at caret
          value: value.substring(0, updatedSelection) + value.substring(selectionEnd),
          // Update caret position
          selectionStart: updatedSelection,
          selectionEnd: updatedSelection
        });
      }
    } else if (event.key === KEYS.ENTER) {
      // On enter add indentation correctly and only when there
      // is no selection.
      if (!hasSelection) {
        // Get the current line
        const line = getLines(value, selectionStart).pop();
        // Check if the current line has any indentation
        const matches = line?.match(/^\s+/);
        if (matches?.[0]) {
          // prevent the default action
          event.preventDefault();

          // Preserve indentation on inserting a new line
          const indent = '\n' + matches[0];
          const updatedSelection = selectionStart + indent.length;
          applyEdits({
            // Insert indentation character at caret
            value: value.substring(0, selectionStart) + indent + value.substring(selectionEnd),
            // Update caret position
            selectionStart: updatedSelection,
            selectionEnd: updatedSelection
          });
        }
      }
    } else if (isEnclosingCharacter(event.key)) {
      // if there is a selection, then enclose them in the characters
      if (hasSelection) {
        // prevent default
        event.preventDefault();
        const chars = ENCLOSING_PAIRS[event.key];
        applyEdits({
          value: value.substring(0, selectionStart) + chars[0] + value.substring(selectionStart, selectionEnd) + chars[1] + value.substring(selectionEnd),
          // Update caret position
          selectionStart,
          selectionEnd: selectionEnd + 2
        });
      }
    } else if (isUndo(event)) {
      event.preventDefault();
      undoEdit();
    } else if (isRedo(event)) {
      event.preventDefault();
      redoEdit();
    } else if (isCaptureToggle(event)) {
      event.preventDefault();
      shouldCaptureTab = !shouldCaptureTab;
    }
  };

  /*******************
   * Lifecycle hooks *
   *******************/

  solidJs.onMount(() => {
    if (!textareaElement) return;
    recordChange(history, {
      selectionEnd: textareaElement.selectionEnd,
      selectionStart: textareaElement.selectionStart,
      value: textareaElement.value
    });
  });
  return (() => {
    const _el$ = _tmpl$(),
      _el$2 = _el$.firstChild,
      _el$3 = _el$2.nextSibling,
      _el$4 = _el$3.nextSibling;
    web.spread(_el$, web.mergeProps(rest, {
      get style() {
        return {
          ...STYLES.CONTAINER,
          ...local.style
        };
      }
    }), false, true);
    web.addEventListener(_el$2, "keyup", local.onKeyUp, true);
    _el$2.$$keydown = handleKeyDown;
    web.addEventListener(_el$2, "focus", local.onFocus);
    web.addEventListener(_el$2, "click", local.onClick, true);
    _el$2.$$input = handleChange;
    web.addEventListener(_el$2, "blur", local.onBlur);
    const _ref$ = textareaElement;
    typeof _ref$ === "function" ? web.use(_ref$, _el$2) : textareaElement = _el$2;
    web.setAttribute(_el$2, "data-gramm", false);
    web.setAttribute(_el$2, "spellcheck", false);
    web.spread(_el$3, web.mergeProps({
      get ["class"]() {
        return local.preClass;
      },
      get style() {
        return {
          ...STYLES.EDITOR,
          ...STYLES.HIGHLIGHT,
          ...contentStyle()
        };
      }
    }, () => typeof highlighted() === 'string' ? {
      innerHTML: `${highlighted()}<br/>`
    } : {
      children: highlighted()
    }), false, false);
    _el$4.innerHTML = SHOW_PLACEHOLDER_STYLES;
    web.effect(_p$ => {
      const _v$ = local.autofocus,
        _v$2 = clsx(TEXTAREA_CLASS, local.textareaClass),
        _v$3 = local.disabled,
        _v$4 = local.form,
        _v$5 = local.textareaId,
        _v$6 = local.maxLength,
        _v$7 = local.minLength,
        _v$8 = local.name,
        _v$9 = local.placeholder,
        _v$10 = local.readOnly,
        _v$11 = local.required,
        _v$12 = {
          ...STYLES.EDITOR,
          ...STYLES.TEXTAREA,
          ...contentStyle()
        };
      _v$ !== _p$._v$ && (_el$2.autofocus = _p$._v$ = _v$);
      _v$2 !== _p$._v$2 && web.className(_el$2, _p$._v$2 = _v$2);
      _v$3 !== _p$._v$3 && (_el$2.disabled = _p$._v$3 = _v$3);
      _v$4 !== _p$._v$4 && web.setAttribute(_el$2, "form", _p$._v$4 = _v$4);
      _v$5 !== _p$._v$5 && web.setAttribute(_el$2, "id", _p$._v$5 = _v$5);
      _v$6 !== _p$._v$6 && web.setAttribute(_el$2, "maxlength", _p$._v$6 = _v$6);
      _v$7 !== _p$._v$7 && web.setAttribute(_el$2, "minlength", _p$._v$7 = _v$7);
      _v$8 !== _p$._v$8 && web.setAttribute(_el$2, "name", _p$._v$8 = _v$8);
      _v$9 !== _p$._v$9 && web.setAttribute(_el$2, "placeholder", _p$._v$9 = _v$9);
      _v$10 !== _p$._v$10 && (_el$2.readOnly = _p$._v$10 = _v$10);
      _v$11 !== _p$._v$11 && (_el$2.required = _p$._v$11 = _v$11);
      _p$._v$12 = web.style(_el$2, _v$12, _p$._v$12);
      return _p$;
    }, {
      _v$: undefined,
      _v$2: undefined,
      _v$3: undefined,
      _v$4: undefined,
      _v$5: undefined,
      _v$6: undefined,
      _v$7: undefined,
      _v$8: undefined,
      _v$9: undefined,
      _v$10: undefined,
      _v$11: undefined,
      _v$12: undefined
    });
    web.effect(() => _el$2.value = local.value);
    return _el$;
  })();
};
web.delegateEvents(["input", "click", "keydown", "keyup"]);

exports.Editor = Editor;
exports.default = Editor;
//# sourceMappingURL=index.common.js.map
